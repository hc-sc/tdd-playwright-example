/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { expect } from './expect';
import { FixturePool } from './fixtures';
import { TestModifier } from './testModifier';
export declare type SpecType = 'default' | 'skip' | 'only';
export declare type Implementation = {
    it: (spec: SpecType, folio: FolioImpl, ...args: any[]) => void;
    describe: (spec: SpecType, folio: FolioImpl, ...args: any[]) => void;
    beforeEach: (folio: FolioImpl, fn: Function) => void;
    afterEach: (folio: FolioImpl, fn: Function) => void;
    beforeAll: (folio: FolioImpl, fn: Function) => void;
    afterAll: (folio: FolioImpl, fn: Function) => void;
};
export declare function setImplementation(i: Implementation): void;
interface DescribeHelper<WorkerParameters> {
    describe(name: string, inner: () => void): void;
    describe(name: string, modifierFn: (modifier: TestModifier, parameters: WorkerParameters) => any, inner: () => void): void;
}
declare type DescribeFunction<WorkerParameters> = DescribeHelper<WorkerParameters>['describe'];
interface ItHelper<WorkerParameters, WorkerFixtures, TestFixtures> {
    it(name: string, inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void> | void): void;
    it(name: string, modifierFn: (modifier: TestModifier, parameters: WorkerParameters) => any, inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void> | void): void;
}
declare type ItFunction<WorkerParameters, WorkerFixtures, TestFixtures> = ItHelper<WorkerParameters, WorkerFixtures, TestFixtures>['it'];
declare type It<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures> & {
    only: ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
    skip: ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
};
declare type Fit<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
declare type Xit<WorkerParameters, WorkerFixtures, TestFixtures> = ItFunction<WorkerParameters, WorkerFixtures, TestFixtures>;
declare type Describe<WorkerParameters> = DescribeFunction<WorkerParameters> & {
    only: DescribeFunction<WorkerParameters>;
    skip: DescribeFunction<WorkerParameters>;
};
declare type BeforeEach<WorkerParameters, WorkerFixtures, TestFixtures> = (inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void>) => void;
declare type AfterEach<WorkerParameters, WorkerFixtures, TestFixtures> = (inner: (fixtures: WorkerParameters & WorkerFixtures & TestFixtures) => Promise<void>) => void;
declare type BeforeAll<WorkerFixtures> = (inner: (fixtures: WorkerFixtures) => Promise<void>) => void;
declare type AfterAll<WorkerFixtures> = (inner: (fixtures: WorkerFixtures) => Promise<void>) => void;
export declare class FolioImpl<TestFixtures = {}, WorkerFixtures = {}, WorkerParameters = {}> {
    it: It<WorkerParameters, WorkerFixtures, TestFixtures>;
    fit: Fit<WorkerParameters, WorkerFixtures, TestFixtures>;
    xit: Xit<WorkerParameters, WorkerFixtures, TestFixtures>;
    test: It<WorkerParameters, WorkerFixtures, TestFixtures>;
    describe: Describe<WorkerParameters>;
    beforeEach: BeforeEach<WorkerParameters, WorkerFixtures, TestFixtures>;
    afterEach: AfterEach<WorkerParameters, WorkerFixtures, TestFixtures>;
    beforeAll: BeforeAll<WorkerFixtures>;
    afterAll: AfterAll<WorkerFixtures>;
    expect: typeof expect;
    _pool: FixturePool;
    constructor(pool: FixturePool);
    union<T, W, P>(other: Folio<T, W, P>): Folio<TestFixtures & T, WorkerFixtures & W, WorkerParameters & P>;
    extend<T = {}, W = {}, P = {}>(): Fixtures<TestFixtures, WorkerFixtures, WorkerParameters, T, W, P>;
    generateParametrizedTests<T extends keyof WorkerParameters>(name: T, values: WorkerParameters[T][]): void;
}
declare type TestFixtureOptions = {
    auto?: boolean;
    scope?: 'test';
};
declare type WorkerFixtureOptions = {
    auto?: boolean;
    scope: 'worker';
};
declare type WorkerParameterInitializer<R> = {
    initParameter(description: string, defaultValue: R): void;
};
declare type WorkerFixtureInitializer<PW, R> = {
    init(fixture: (params: PW, runTest: (value: R) => Promise<void>) => Promise<void>, options: WorkerFixtureOptions): void;
};
declare type WorkerFixtureOverrider<PW, R> = {
    override(fixture: (params: PW, runTest: (value: R) => Promise<void>) => Promise<void>): void;
};
declare type TestFixtureInitializer<PWT, R> = {
    init(fixture: (params: PWT, runTest: (value: R) => Promise<void>) => Promise<void>, options?: TestFixtureOptions): void;
};
declare type TestFixtureOverrider<PWT, R> = {
    override(fixture: (params: PWT, runTest: (value: R) => Promise<void>) => Promise<void>): void;
};
declare type Fixtures<TestFixtures, WorkerFixtures, WorkerParameters, T, W, P> = {
    [X in keyof P]: WorkerParameterInitializer<P[X]>;
} & {
    [X in keyof W]: WorkerFixtureInitializer<WorkerParameters & P & WorkerFixtures & W, W[X]>;
} & {
    [X in keyof T]: TestFixtureInitializer<WorkerParameters & P & WorkerFixtures & W & TestFixtures & T, T[X]>;
} & {
    [X in keyof WorkerFixtures]: WorkerFixtureOverrider<WorkerParameters & P & WorkerFixtures & W, WorkerFixtures[X]>;
} & {
    [X in keyof TestFixtures]: TestFixtureOverrider<WorkerParameters & P & WorkerFixtures & W & TestFixtures & T, TestFixtures[X]>;
} & {
    build(): Folio<TestFixtures & T, WorkerFixtures & W, WorkerParameters & P>;
};
export interface Folio<T, W, P> extends FolioImpl<T, W, P> {
}
export declare const rootFixtures: Folio<{}, {}, {}>;
export {};
//# sourceMappingURL=spec.d.ts.map