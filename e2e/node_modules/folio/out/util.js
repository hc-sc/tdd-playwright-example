"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prependErrorMessage = exports.monotonicTime = exports.errorWithCallLocation = exports.callLocation = exports.serializeError = exports.raceAgainstDeadline = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const stack_utils_1 = __importDefault(require("stack-utils"));
const FOLIO_DIRS = [__dirname, path_1.default.join(__dirname, '..', 'src')];
const cwd = process.cwd();
const stackUtils = new stack_utils_1.default({ cwd });
async function raceAgainstDeadline(promise, deadline) {
    if (!deadline)
        return { result: await promise };
    const timeout = deadline - monotonicTime();
    if (timeout <= 0)
        return { timedOut: true };
    let timer;
    let done = false;
    let fulfill;
    let reject;
    const result = new Promise((f, r) => {
        fulfill = f;
        reject = r;
    });
    setTimeout(() => {
        done = true;
        fulfill({ timedOut: true });
    }, timeout);
    promise.then(result => {
        clearTimeout(timer);
        if (!done) {
            done = true;
            fulfill({ result });
        }
    }).catch(e => {
        clearTimeout(timer);
        if (!done)
            reject(e);
    });
    return result;
}
exports.raceAgainstDeadline = raceAgainstDeadline;
function serializeError(error) {
    if (error instanceof Error) {
        return {
            message: error.message,
            stack: error.stack
        };
    }
    return {
        value: util_1.default.inspect(error)
    };
}
exports.serializeError = serializeError;
function callFrames() {
    const obj = { stack: '' };
    Error.captureStackTrace(obj);
    const frames = obj.stack.split('\n').slice(1);
    while (frames.length && FOLIO_DIRS.some(dir => frames[0].includes(dir)))
        frames.shift();
    return frames;
}
function callLocation(fallbackFile) {
    const frames = callFrames();
    if (!frames.length)
        return { file: fallbackFile, line: 1, column: 1 };
    const location = stackUtils.parseLine(frames[0]);
    return {
        file: path_1.default.resolve(cwd, location.file),
        line: location.line,
        column: location.column,
    };
}
exports.callLocation = callLocation;
function errorWithCallLocation(message) {
    const frames = callFrames();
    const error = new Error(message);
    error.stack = 'Error: ' + message + '\n' + frames.join('\n');
    return error;
}
exports.errorWithCallLocation = errorWithCallLocation;
function monotonicTime() {
    const [seconds, nanoseconds] = process.hrtime();
    return seconds * 1000 + (nanoseconds / 1000000 | 0);
}
exports.monotonicTime = monotonicTime;
function prependErrorMessage(e, message) {
    let stack = e.stack || '';
    if (stack.includes(e.message))
        stack = stack.substring(stack.indexOf(e.message) + e.message.length);
    let m = e.message;
    if (m.startsWith('Error:'))
        m = m.substring('Error:'.length);
    e.message = message + m;
    e.stack = e.message + stack;
}
exports.prependErrorMessage = prependErrorMessage;
//# sourceMappingURL=util.js.map