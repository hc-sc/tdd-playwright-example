"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.rootFixtures = exports.FolioImpl = exports.setImplementation = void 0;
const expect_1 = require("./expect");
const fixtures_1 = require("./fixtures");
const util_1 = require("./util");
Error.stackTraceLimit = 15;
let implementation;
function setImplementation(i) {
    implementation = i;
}
exports.setImplementation = setImplementation;
class FolioImpl {
    constructor(pool) {
        this._pool = pool;
        this.expect = expect_1.expect;
        this.it = ((...args) => {
            implementation.it('default', this, ...args);
        });
        this.test = this.it;
        this.it.skip = (...args) => implementation.it('skip', this, ...args);
        this.it.only = (...args) => implementation.it('only', this, ...args);
        this.fit = this.it.only;
        this.xit = this.it.skip;
        this.describe = ((...args) => {
            implementation.describe('default', this, ...args);
        });
        this.describe.skip = (...args) => implementation.describe('skip', this, ...args);
        this.describe.only = (...args) => implementation.describe('only', this, ...args);
        this.beforeEach = fn => implementation.beforeEach(this, fn);
        this.afterEach = fn => implementation.afterEach(this, fn);
        this.beforeAll = fn => implementation.beforeAll(this, fn);
        this.afterAll = fn => implementation.afterAll(this, fn);
    }
    union(other) {
        const pool = this._pool.union(other._pool);
        pool.validate();
        return new FolioImpl(pool);
    }
    extend() {
        return new Proxy(new FixturesImpl(new fixtures_1.FixturePool(this._pool)), proxyHandler);
    }
    generateParametrizedTests(name, values) {
        fixtures_1.setParameterValues(name, values);
    }
}
exports.FolioImpl = FolioImpl;
class FixturesImpl {
    constructor(pool) {
        this._pool = pool;
        this._finished = false;
    }
    _init(name, fixture, options) {
        if (this._finished)
            throw util_1.errorWithCallLocation(`Should not modify fixtures after build()`);
        this._pool.registerFixture(name, options && options.scope === 'worker' ? 'worker' : 'test', fixture, options && options.auto);
    }
    _override(name, fixture) {
        if (this._finished)
            throw util_1.errorWithCallLocation(`Should not modify fixtures after build()`);
        this._pool.overrideFixture(name, fixture);
    }
    _initParameter(name, description, defaultValue) {
        if (this._finished)
            throw util_1.errorWithCallLocation(`Should not modify fixtures after build()`);
        this._pool.registerFixture(name, 'worker', async ({}, runTest) => runTest(defaultValue), false);
        this._pool.registerWorkerParameter({
            name: name,
            description,
            defaultValue: defaultValue,
        });
    }
    build() {
        if (this._finished)
            throw util_1.errorWithCallLocation(`Should not call build() twice`);
        this._pool.validate();
        this._finished = true;
        return new FolioImpl(this._pool);
    }
}
const proxyHandler = {
    get: (target, prop, receiver) => {
        if (prop in target)
            return target[prop];
        if (typeof prop !== 'string' || prop === 'then')
            return undefined;
        return {
            initParameter: (description, defaultValue) => target._initParameter(prop, description, defaultValue),
            init: (fn, options) => target._init(prop, fn, options),
            override: fn => target._override(prop, fn),
        };
    },
};
exports.rootFixtures = new FolioImpl(new fixtures_1.FixturePool(undefined));
//# sourceMappingURL=spec.js.map