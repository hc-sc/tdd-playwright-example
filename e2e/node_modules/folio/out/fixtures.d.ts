/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { Config } from './config';
import { TestStatus, Parameters } from './test';
declare type Scope = 'test' | 'worker';
declare type FixtureRegistration = {
    name: string;
    scope: Scope;
    fn: Function;
    auto: boolean;
    isOverride: boolean;
    deps: string[];
    super?: FixtureRegistration;
};
export declare type TestInfo = {
    title: string;
    file: string;
    line: number;
    column: number;
    fn: Function;
    parameters: Parameters;
    workerIndex: number;
    repeatEachIndex: number;
    retry: number;
    expectedStatus: TestStatus;
    timeout: number;
    duration: number;
    status?: TestStatus;
    error?: any;
    stdout: (string | Buffer)[];
    stderr: (string | Buffer)[];
    data: any;
    relativeArtifactsPath: string;
    snapshotPath: (...pathSegments: string[]) => string;
    outputPath: (...pathSegments: string[]) => string;
};
export declare function setCurrentTestInfo(testInfo: TestInfo | null): void;
export declare function currentTestInfo(): TestInfo | null;
export declare type ParameterRegistration = {
    name: string;
    description: string;
    defaultValue: string | number | boolean;
};
export declare const parameterRegistrations: Map<string, ParameterRegistration>;
export declare let parameters: Parameters;
export declare function assignParameters(params: any): void;
export declare const matrix: {
    [name: string]: any;
};
export declare function setParameterValues(name: string, values: any[]): void;
export declare let config: Config;
export declare function assignConfig(c: Config): void;
declare class Fixture {
    pool: FixturePool;
    registration: FixtureRegistration;
    usages: Set<Fixture>;
    hasGeneratorValue: boolean;
    value: any;
    _teardownFenceCallback: (value?: unknown) => void;
    _tearDownComplete: Promise<void>;
    _setup: boolean;
    _teardown: boolean;
    constructor(pool: FixturePool, registration: FixtureRegistration);
    setup(): Promise<void>;
    teardown(): Promise<void>;
}
export declare class FixturePool {
    id: number;
    parentPool: FixturePool | undefined;
    instances: Map<FixtureRegistration, Fixture>;
    registrations: Map<string, FixtureRegistration>;
    constructor(parentPool: FixturePool | undefined);
    union(other: FixturePool): FixturePool;
    registerFixture(name: string, scope: Scope, fn: Function, auto: boolean): void;
    overrideFixture(name: string, fn: Function): void;
    registerWorkerParameter(parameter: ParameterRegistration): void;
    validate(): void;
    parametersForFunction(fn: Function, prefix: string, allowTestFixtures: boolean): string[];
    setupFixture(name: string): Promise<Fixture>;
    setupFixtureForRegistration(registration: FixtureRegistration): Promise<Fixture>;
    teardownScope(scope: string): Promise<void>;
    resolveParametersAndRunHookOrTest(fn: Function): Promise<any>;
    _resolveDependency(registration: FixtureRegistration, name: string): FixtureRegistration | undefined;
}
export {};
//# sourceMappingURL=fixtures.d.ts.map