"use strict";
/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = exports.Suite = exports.Test = void 0;
const rimraf_1 = __importDefault(require("rimraf"));
const util_1 = require("util");
const dispatcher_1 = require("./dispatcher");
const fixtures_1 = require("./fixtures");
const testGenerator_1 = require("./testGenerator");
const util_2 = require("./util");
const runnerTest_1 = require("./runnerTest");
const runnerSpec_1 = require("./runnerSpec");
const debug_1 = require("./debug");
const spec_1 = require("./spec");
var test_1 = require("./test");
Object.defineProperty(exports, "Test", { enumerable: true, get: function () { return test_1.Test; } });
Object.defineProperty(exports, "Suite", { enumerable: true, get: function () { return test_1.Suite; } });
const removeFolderAsync = util_1.promisify(rimraf_1.default);
class Runner {
    constructor(reporter) {
        this._suites = [];
        this._reporter = reporter;
    }
    loadFiles(files) {
        debug_1.debugLog(`loadFiles`, files);
        // First traverse tests.
        for (const file of files) {
            const suite = new runnerTest_1.RunnerSuite(spec_1.rootFixtures, '');
            suite.file = file;
            const revertBabelRequire = runnerSpec_1.runnerSpec(suite, fixtures_1.config);
            try {
                require(file);
            }
            catch (e) {
                util_2.prependErrorMessage(e, `Error while reading ${file}:\n`);
                throw e;
            }
            this._suites.push(suite);
            revertBabelRequire();
        }
        // Set default values
        for (const param of fixtures_1.parameterRegistrations.values()) {
            if (!(param.name in fixtures_1.matrix))
                fixtures_1.setParameterValues(param.name, [param.defaultValue]);
        }
        return { parameters: fixtures_1.parameterRegistrations };
    }
    generateTests(options = {}) {
        if (options.parameters) {
            for (const name of Object.keys(options.parameters))
                fixtures_1.setParameterValues(name, options.parameters[name]);
        }
        // We can only generate tests after parameters have been assigned.
        this._suites = excludeNonOnlyFiles(this._suites);
        this._rootSuite = testGenerator_1.generateTests(this._suites, fixtures_1.config);
        return this._rootSuite;
    }
    list() {
        this._reporter.onBegin(fixtures_1.config, this._rootSuite);
        this._reporter.onEnd();
    }
    async run() {
        await removeFolderAsync(fixtures_1.config.outputDir).catch(e => { });
        if (fixtures_1.config.forbidOnly) {
            const hasOnly = this._rootSuite.findSpec(t => t._only) || this._rootSuite.findSuite(s => s._only);
            if (hasOnly)
                return 'forbid-only';
        }
        const total = this._rootSuite.total;
        if (!total)
            return 'no-tests';
        const globalDeadline = fixtures_1.config.globalTimeout ? fixtures_1.config.globalTimeout + util_2.monotonicTime() : 0;
        const { result, timedOut } = await util_2.raceAgainstDeadline(this._runTests(this._rootSuite), globalDeadline);
        if (timedOut) {
            this._reporter.onTimeout(fixtures_1.config.globalTimeout);
            process.exit(1);
        }
        return result;
    }
    async _runTests(suite) {
        // Trial run does not need many workers, use one.
        const runner = new dispatcher_1.Dispatcher(suite, { ...fixtures_1.config, workers: fixtures_1.config.workers }, this._reporter);
        let sigint = false;
        let sigintCallback;
        const sigIntPromise = new Promise(f => sigintCallback = f);
        const sigintHandler = () => {
            process.off('SIGINT', sigintHandler);
            sigint = true;
            sigintCallback();
        };
        process.on('SIGINT', sigintHandler);
        this._reporter.onBegin(fixtures_1.config, suite);
        await Promise.race([runner.run(), sigIntPromise]);
        await runner.stop();
        this._reporter.onEnd();
        if (sigint)
            return 'sigint';
        return runner.hasWorkerErrors() || suite.findSpec(spec => !spec.ok()) ? 'failed' : 'passed';
    }
}
exports.Runner = Runner;
function excludeNonOnlyFiles(suites) {
    // This makes sure we don't generate 1000000 tests if only one spec is focused.
    const filtered = suites.filter(suite => suite._hasOnly());
    return filtered.length === 0 ? suites : filtered;
}
//# sourceMappingURL=runner.js.map