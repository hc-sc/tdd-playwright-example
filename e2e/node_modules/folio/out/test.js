"use strict";
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = exports.Suite = exports.Spec = void 0;
const util_1 = require("./util");
class Base {
    constructor(folio, title, parent) {
        this._only = false;
        this._folio = folio;
        this.title = title;
        this.parent = parent;
        // Root suite has default fixtures that do not match all others.
        if (parent && parent.parent && parent._folio !== folio)
            throw util_1.errorWithCallLocation(`Mixing different fixture sets in the same suite.\nAre you using it and describe from different fixture files?`);
    }
    titlePath() {
        if (!this.parent)
            return [];
        if (!this.title)
            return this.parent.titlePath();
        return [...this.parent.titlePath(), this.title];
    }
    fullTitle() {
        return this.titlePath().join(' ');
    }
}
class Spec extends Base {
    constructor(fixtures, title, fn, suite) {
        super(fixtures, title, suite);
        this.tests = [];
        this.fn = fn;
        suite._addSpec(this);
    }
    ok() {
        return !this.tests.find(r => !r.ok());
    }
}
exports.Spec = Spec;
class Suite extends Base {
    constructor(fixtures, title, parent) {
        super(fixtures, title, parent);
        this.suites = [];
        this.specs = [];
        this._entries = [];
        this.total = 0;
        if (parent)
            parent._addSuite(this);
    }
    _addSpec(spec) {
        spec.parent = this;
        this.specs.push(spec);
        this._entries.push(spec);
    }
    _addSuite(suite) {
        suite.parent = this;
        this.suites.push(suite);
        this._entries.push(suite);
    }
    findTest(fn) {
        for (const suite of this.suites) {
            if (suite.findTest(fn))
                return true;
        }
        for (const spec of this.specs) {
            for (const test of spec.tests) {
                if (fn(test))
                    return true;
            }
        }
        return false;
    }
    findSpec(fn) {
        for (const suite of this.suites) {
            if (suite.findSpec(fn))
                return true;
        }
        for (const spec of this.specs) {
            if (fn(spec))
                return true;
        }
        return false;
    }
    findSuite(fn) {
        if (fn(this))
            return true;
        for (const suite of this.suites) {
            if (suite.findSuite(fn))
                return true;
        }
        return false;
    }
    _allSpecs() {
        const result = [];
        this.findSpec(test => { result.push(test); });
        return result;
    }
    _renumber() {
        // All tests are identified with their ordinals.
        let ordinal = 0;
        this.findSpec((test) => {
            test._ordinal = ordinal++;
        });
    }
    _countTotal() {
        this.total = 0;
        for (const suite of this.suites) {
            suite._countTotal();
            this.total += suite.total;
        }
        for (const spec of this.specs)
            this.total += spec.tests.length;
    }
    _hasOnly() {
        if (this._only)
            return true;
        if (this.suites.find(suite => suite._hasOnly()))
            return true;
        if (this.specs.find(spec => spec._only))
            return true;
    }
}
exports.Suite = Suite;
class Test {
    constructor(spec) {
        this.results = [];
        this.skipped = false;
        this.flaky = false;
        this.slow = false;
        this.expectedStatus = 'passed';
        this.timeout = 0;
        this.annotations = [];
        this.spec = spec;
    }
    status() {
        if (this.skipped)
            return 'skipped';
        // List mode bail out.
        if (!this.results.length)
            return 'skipped';
        if (this.results.length === 1 && this.expectedStatus === this.results[0].status)
            return 'expected';
        let hasPassedResults = false;
        for (const result of this.results) {
            // Missing status is Ok when running in shards mode.
            if (!result.status)
                return 'skipped';
            if (result.status === this.expectedStatus)
                hasPassedResults = true;
        }
        if (hasPassedResults)
            return this.flaky ? 'expected-flaky' : 'unexpected-flaky';
        return 'unexpected';
    }
    ok() {
        const status = this.status();
        return status === 'expected' || status === 'expected-flaky' || status === 'skipped';
    }
}
exports.Test = Test;
//# sourceMappingURL=test.js.map