"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.runnerSpec = void 0;
const transform_1 = require("./transform");
const runnerTest_1 = require("./runnerTest");
const util_1 = require("./util");
const spec_1 = require("./spec");
function runnerSpec(suite, config) {
    const suites = [suite];
    const it = (spec, folio, title, modifierFn, fn) => {
        const suite = suites[0];
        if (typeof fn !== 'function') {
            fn = modifierFn;
            modifierFn = null;
        }
        const test = new runnerTest_1.RunnerSpec(folio, title, fn, suite);
        test._usedParameters = folio._pool.parametersForFunction(fn, `Test`, true);
        const location = util_1.callLocation(suite.file);
        test.file = location.file;
        test.line = location.line;
        test.column = location.column;
        if (spec === 'only')
            test._only = true;
        test._modifierFn = (modifier, parameters) => {
            if (spec === 'skip')
                modifier.skip();
            if (!modifier._timeout)
                modifier.setTimeout(config.timeout);
            if (modifierFn)
                modifierFn(modifier, parameters);
        };
        return test;
    };
    const describe = (spec, folio, title, modifierFn, fn) => {
        if (typeof fn !== 'function') {
            fn = modifierFn;
            modifierFn = null;
        }
        const child = new runnerTest_1.RunnerSuite(folio, title, suites[0]);
        const location = util_1.callLocation(suite.file);
        child.file = location.file;
        child.line = location.line;
        child.column = location.column;
        if (spec === 'only')
            child._only = true;
        child._modifierFn = (modifier, parameters) => {
            if (spec === 'skip')
                modifier.skip();
            if (!modifier._timeout)
                modifier.setTimeout(config.timeout);
            if (modifierFn)
                modifierFn(modifier, parameters);
        };
        suites.unshift(child);
        fn();
        suites.shift();
    };
    const hook = (hookName, folio, fn) => {
        const suite = suites[0];
        if (!suite.parent)
            throw util_1.errorWithCallLocation(`${hookName} hook should be called inside a describe block. Consider using an auto fixture.`);
        if (suite._folio !== folio)
            throw util_1.errorWithCallLocation(`Using ${hookName} hook from a different fixture set.\nAre you using describe and ${hookName} from different fixture files?`);
        suite._usedParameters.push(...folio._pool.parametersForFunction(fn, `${hookName} hook`, hookName === 'beforeEach' || hookName === 'afterEach'));
    };
    spec_1.setImplementation({
        it,
        describe,
        beforeEach: (folio, fn) => hook('beforeEach', folio, fn),
        afterEach: (folio, fn) => hook('afterEach', folio, fn),
        beforeAll: (folio, fn) => hook('beforeAll', folio, fn),
        afterAll: (folio, fn) => hook('afterAll', folio, fn),
    });
    return transform_1.installTransform();
}
exports.runnerSpec = runnerSpec;
//# sourceMappingURL=runnerSpec.js.map